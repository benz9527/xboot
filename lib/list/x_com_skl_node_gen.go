// Auto generated code; Do NOT EDIT!
// Author benzheng2121@126.com

package list

import (
	"github.com/benz9527/xboot/lib/infra"
)

func genXComSklNode[K infra.OrderedKey, V any](
	key K,
	val V,
	lvl int32,
) *xComSklNode[K, V] {
	switch lvl {
	case 1: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [1]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 2: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [2]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 3: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [3]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 4: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [4]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 5: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [5]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 6: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [6]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 7: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [7]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 8: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [8]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 9: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [9]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 10: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [10]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 11: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [11]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 12: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [12]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 13: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [13]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 14: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [14]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 15: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [15]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 16: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [16]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 17: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [17]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 18: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [18]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 19: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [19]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 20: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [20]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 21: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [21]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 22: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [22]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 23: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [23]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 24: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [24]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 25: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [25]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 26: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [26]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 27: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [27]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 28: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [28]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 29: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [29]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 30: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [30]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 31: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [31]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	case 32: 
	  n := struct {
		node    xComSklNode[K, V]
		indices [32]*xComSklNode[K, V]
		element xSklElement[K, V]
	  }{
		element: xSklElement[K, V]{
			key: key,
			val: val,
		},
	  }
	  n.node.indices = n.indices[:]
	  n.node.element = &n.element
	  return &n.node
	default:
	}
	panic("unable to generate ")
}
