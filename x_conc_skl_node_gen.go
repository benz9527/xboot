// Auto generated code; Do NOT EDIT!
package main

import (
	"github.com/benz9527/xboot/lib/infra"
)

func genXConcSklNode[K infra.OrderedKey, V any](
	lvl int32,
) *xConcSklNode[K, V] {
	switch lvl {
	case 0 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 1 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 2 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 3 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 4 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 5 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 6 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 7 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 8 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 9 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 10 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 11 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 12 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 13 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 14 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 15 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 16 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 17 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 18 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 19 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 20 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 21 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 22 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 23 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 24 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 25 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 26 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 27 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 28 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 29 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 30 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	case 31 : 
	  n := struct {
		node    xConcSklNode[K, V]
		indices [$i]*xConcSklNode[K, V]
		xN      xNode[V]
	  }{}
	  n.node.indices = n.indices[:]
	  n.node.root = &n.xN
	  return &n.node
	default:
	}
	panic("unable to generate ")
}
